# Лекция 6

Темы, расмотренные в лекции:
- библиотеки;
- типы библиотек;
- создание собственных статических библиотек;
- создание собственных динамическиз библиотек.

## Зачем нужны библиотеки

Библиотеки предназначены для внедрения способа конструирования программного обеспечения, также известного, как "разделяемые компоненты" или "архивные библиотеки", который заключается в объединении нескольких скомпилированных объектных файлов в один, также известный как библиотека. Как правило, функции, которые могут быть использованы более чем в одном приложении, выносятся за пределы исходного кода приложения, компилируются и объединяются в библиотеку. Стандартная библиотека C является примером разделяемого компонента, который может быть привязан к вашему коду. Преимущество заключается в том, что нет необходимости указывать каждый отдельный объектный файл во время связывания (*линковки*), так как можно указать на всю библиотеку в целом. Это упрощает повторное использование и разделение компонентов программного обеспечения между приложениями. Также это позволяет произоводителям приложения легко выпустить свой API для взаимодействия с ним. Большие компоненты могут быть созданы для динамического использования. Таким образом библиотека может существовать отдельно от исполняеого файла, уменьшая тем самым его размер и, как следствие, уменьшая объем занимаемого приложением дискового пространства. Компоненты библиотеки в последствии вызываются различными приложениями, когда им это необходимо.

Преимущества использования библиотек:

- Многократное использование компонентов: обновляется только библиотека, разделяемые ресурсы занимают меньше дискового пространства.
- Управление версиями: Linux-библиотеки могут сосуществовать в виде старых и новых версий на одной системе.
- Специализация компонентов: нишевые и специализированные разработчики могут сфокусироваться на их основной зоне компетенции в рамках одной библиотеки. Упрощается тестирование и проверка.

## Виды Linux-библиотек

Есть два типа Linux-библиотек на C, которые могут быть созданы:

1. Статические библиотеки (.a): Библиотеки объектного кода, которые связываются с приложением и становятся его частью.
2. Динамически связываемые библиотеки (.so): Есть только одна форма существования подобной библиотеки, но она может использоваться двумя способами:
	1. Динамически подключаемая во время выполнения. Такие библиотеки должны быть доступны во время компиляции/связывания. Разделяемые объекты не включаются в исполняемые компоненты, но привязываются к исполнению.
	2. Динамически загружаемые/выгружаемые и связываемые во время выполнения (как, например, плагины в браузере) при помощи системных функций динамической загрузки.

### Соглашения о названиях библиотек

Библиотеки как правило называются с префиксом "lib". Это так для всех стандартных библиотек C. При связывании, в командной строке ссылка на библиотеку не будет содержать префикс или суффикс.

Например, рассмотрим следу команду для компиляции и связывания:

`gcc src-file.c -lm -lpthread`

Библиотеки, указанные в этом примери для включения во время свяывания - математическая библиотека ("m") и библиотека управления тредами ("pthread"). Их можно отыскать в /usr/lib/libm.a и /usr/lib/libpthread.a.

**Замечание:** Компилятор GNU сейчас имеет опцию командной строки "-pthread" в то время, как более старые версии компилятора требуют указания данной библиотеки явно как "-lpthread". Поэтому сейчас вы наиболее вероятно столкнетесь с первым вариантом src-file.c -lm -pthread.

## Статические библиотеки (.a)

Как сгенерировать статическую библиотеку (архивный файл объектного кода):
- Компиляция: `cc -Wall -c ctest1.c ctest2.c`
- Создание библиотеки "libctest.a": `cc -Wall -c ctest1.c ctest2.c`
- Перечисление файлов в библиотеке: `ar -t libctest.a`
- Связывание с библиотекой:
	- `cc -o executable-name prog.c libctest.a`
	- `cc -o executable-name prog.c -L/path/to/library-directory -lctest`
- Файлы для примера:
- ctest1.c

```C
void ctest1(int *i)
{
*i=5;
}
```

- ctest2.c

```C
void ctest2(int *i)
{
   *i=100;
}
```

-prog.c

```C
#include <stdio.h>
void ctest1(int *);
void ctest2(int *);

int main()
{
   int x;
   ctest1(&x);
   printf("Valx=%d\n",x);

   return 0;
}
```

*Историческая справка:* При создании библиотеки раньше было необходимо выполнять команду: `ranlib ctest.a`. Это создавало символьную таблицу в архиве. Ranlib сейчас включен в команду ar.
*Справка для разработчиков в MS/Windows:* Библиотека ".a" в Linux/Unix - концептуальный аналог статической библиотеки ".lib" в Visual C++.

## Динамически связываемые библиотеки (.so)

Как сгенерировать разделяемый объект: (Динмаически связываемый объектный файл библиотеки). Заметьте, что это двухшаговый процесс.

1. Создайте объектный код.
2. Создайте библиотеку.
3. Опционально: создайте версию по умолчанию при помощи символической ссылки.

**Пример создания библиотеки:**

```
gcc -Wall -fPIC -c *.c
gcc -shared -Wl,-soname,libctest.so.1 -o libctest.so.1.0   *.o
mv libctest.so.1.0 /opt/lib
ln -sf /opt/lib/libctest.so.1.0 /opt/lib/libctest.so.1
ln -sf /opt/lib/libctest.so.1.0 /opt/lib/libctest.so
```

Это приведет к созданию библиотеки libctest.so.1.0 и символичесской ссылки на нее.

Также можно включать одну ссылку в другую:

```
ln -sf /opt/lib/libctest.so.1.0 /opt/lib/libctest.so.1
ln -sf /opt/lib/libctest.so.1   /opt/lib/libctest.so
```

Если вы посмотрите на библиотеки в /lib/ и /usr/lib, то обнаружите, что используются оба метода. Linux-разработчики непостоянны. Важно, чтобы символические ссылки в конце концов указывали на настоящую библиотеку.

Опции компилятора:

- -Wall: включить предупреждения.
- -fPIC: директива компилятору давать на выходе позиционно независимый код, обязательно для разделяемых библиотек.
- -shared: создать разделяемый объект, который может быть связан с другими объектами для формирования исполняемого файла.
- -Wl,*опции*: передать опции линковщику. В данном примере передаются опция "-soname libctest.so.1".
- Опция -o: вывод операции. В даном случае имя выходного разделяемого объекта - "libctest.so.1.0".

Ссылки на библиотеку:

- Ссылка на /opt/lib/libctest.so позволяет работать соглашению о названиях для флага компиляции -lctest.
- Ссылка на /opt/lib/libctest.so.1 позволяет работать связыванию во время выполнения. См. ниже.

**Компиляция основной программы и связывание с разделяемой объектной библиотекой:**

Компиляция для свяязывания во время выполнения с динамически связываемым libctest.so.1.0:

`gcc -Wall -I/path/to/include-files -L/path/to/libraries prog.c -lctest -o prog`

Используйте:

`gcc -Wall -L/opt/lib prog.c -lctest -o prog`

Где имя библиотеки - libctest.so (это причина, по которой, вы должны создавать символические ссылки или вы получите ошибку:  "/usr/bin/ld: cannot find -lctest").

Библиотеки НЕ будут выключены в исполняемый файл, но будут динамически связаны во время процесса исполнения.

**Перечисление зависимостей:**

Зависимости разделяемых библиотек исполняемого файла могут быть перчислины при помощи команды: `ldd name-of-executable`

Например: ldd prog

```
libctest.so.1 => /opt/lib/libctest.so.1 (0x00002aaaaaaac000)
libc.so.6 => /lib64/tls/libc.so.6 (0x0000003aa4e00000)
/lib64/ld-linux-x86-64.so.2 (0x0000003aa4c00000)
```

**Будьте внимательны:** Неразрешенные ощибки в разделяемой библиотеке могут вызвать ошибку во время загрузки библиотеки.

Например:

Сообщение об ошиьке во время выполнения:

```
ERROR: unable to load  libname-of-lib.so
ERROR: unable to get function address
```

Исследуем ошибку:

```
[prompt]$ ldd libname-of-lib.so
        libglut.so.3 => /usr/lib64/libglut.so.3 (0x00007fb582b74000)
        libGL.so.1 => /usr/lib64/libGL.so.1 (0x00007fb582857000)
        libX11.so.6 => /usr/lib64/libX11.so.6 (0x00007fb582518000)
        libIL.so.1 (0x00007fa0f2c0f000)
        libcudart.so.4 => not found
```

Первые три библиотеки показывют, что путь для них разренен. Последние две содержат проблему.

Решение - разрешить зависимости последних двух библиотек при связывании libname-of-lib.so:

- Добавьте неразрешенный путь к библиотеке в /etc/ld.so.conf.d/name-of-lib-x86_64.conf и/или /etc/ld.so.conf.d/name-of-lib-i686.conf
Перезагрузите кеш библиотек (/etc/ld.so.cache) командой: `sudo ldconfig`

**Или**

- Добавьте библиотеку и путь явно к команде компилятора/линковщика: `-lname-of-lib -L/path/to/lib`

**Или**

- Добавьте путь к библиотеке к переменной окружения для исправления зависимости во время исполнения:

`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/lib`

**Запустите программу:**

- Установите путь: `export LD_LIBRARY_PATH=/opt/lib:$LD_LIBRARY_PATH`
- Запустите: `prog`


**Пример с кодом:**

Используя пример выше с ctest1.c, ctest2.c и prog.c
1. Скомплилируем библиотечные функции: `-Wall -fPIC -c ctest1.c ctest2.c`
2. Сгенерируем разделяемую библиотеку: `gcc -shared -Wl,-soname,libctest.so.1 -o libctest.so.1.0 ctest1.o ctest2.o`
Это сгенерирует библиотеку libctest.so.1.0
3. Перенесем в директорию lib/:

```
sudo mv libctest.so.1.0 /opt/lib
sudo ln -sf /opt/lib/libctest.so.1.0 /opt/lib/libctest.so.1
sudo ln -sf /opt/lib/libctest.so.1 /opt/lib/libctest.so
```

Скомпилируем программу для использования с разделяемой библиотекой: `gcc -Wall -L/opt/lib prog.c -lctest -o prog`

**Будьте внимательны:** Если не создать символические ссылки (выше), вы получите следующую ошибку:

```
/usr/bin/ld: cannot find -lctest
collect2: error: ld returned 1 exit status
```

Ссылка к названию библиотеки -lctest указывает на /opt/lib/libctest.so

4. Укажите путь к библиотеке (см. ниже один и выберите один из трех механизмов).

В данном примере мы установим переменную окружения: `export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/lib`

5. Запустите программу:

```
./prog
Valx=5
```

**Обратите внимание:** Вы получите следующую ошибку, если не установите путь к библиотеке:

```
./prog: error while loading shared libraries: libctest.so.1: cannot open shared object file: No such file or directory
```

#### Путь к библиотеке

Для того, чтобы исполняемый файл смог найти необходимые библиотеки для связывания во время исполнения, вы должны настроить систему таким образом, чтобы библиотеки могли быть найдены. Вот доступные методы (выполните хотя бы один из них):

1. Добавьте директории библиотек, которые вы хотите включить во время динамического связывания в файл /etc/ld.so.conf
Пример файла /etc/ld.so.conf:

```
/usr/X11R6/lib
/usr/lib
...
..
/usr/lib/sane
/usr/lib/mysql
/opt/lib
```

Добавьте путь к библиотеке в этот файл и затем выполните команду (в качестве администратора) `ldconfig` для настройки связок времени исполнения линковщика.

Вы можете использовать флаг "-f имя_файла" для указания другого файла конфигурации, если вы разрабатываете для различных сред.

**Или**

2. Добавьте директорию к кешу библиотеки (в качестве администратора):

`ldconfig -n /opt/lib`

Где /opt/lib - директория, содержащая вашу библиотеку libctest.so

(Во время разработки и проста добавляения своей текущей директории: `ldconfig -n`. Связывайте с флагом -L.)

Это НЕ заставит постоянно систему включать эту директорию. Информация будет утерена после перезагрузки системы.

**Или**

3. Установите переменную окружения LD_LIBRARY_PATH, чтобы она указывала на путь к директории, содержащей разделяемую объектную библиотеку. Это укажет загрузчику времени исполнения что пути к библиотеки будут использованы во время исполнения для разрешения зависимостей.

(Linux/Solaris: LD_LIBRARY_PATH, SGI: LD_LIBRARYN32_PATH, AIX: LIBPATH, Mac OS X: DYLD_LIBRARY_PATH, HP-UX: SHLIB_PATH)

Пример в bash shell: `export LD_LIBRARY_PATH=/opt/lib:$LD_LIBRARY_PATH` или добавьте к своему файлу ~/.bashrc:

```
 ...
if [ -d /opt/lib ];
then
   LD_LIBRARY_PATH=/opt/lib:$LD_LIBRARY_PATH
fi

...

export LD_LIBRARY_PATH
```

Это сообщит загрузчику времени исполнения посмотреть в указанный переменной окружения путь LD_LIBRARY_PATH для разрешения разделяемых библиотек. Это включит путь /opt/lib.

Пути к библиотекам должны подчиняться сруктуре директорий [Linux Standart Base](www.linuxbase.org).

#### Информация о библиотеке

##### ar: перечисляет объектные файлы в архивной библиотеке

`ar tf /usr/lib/x86_64-linux-gnu/libjpeg.a`

это перечислит все объектные файлы, содержащиеся в архивной библиотеке:

```
jlibinit.o
jcapimin.o
jcapistd.o
jccoefct.o
jccolor.o
jcdctmgr.o
jchuff.o
jcinit.o
...
...
```

##### nm: перечислить символы: объектные файлы, архивные библиотеки и разделяемые библиотеки

Команда "nm" перечисляет символы, содержащиеся в объектных файлах:

`nm file.o`

Команда "nm" перечисляет символы, содержащиеся в архивной библиотеке:

Объектные символы в статической архивной библиотеке категоризируются используя исходный код и иерархию объектных файлов библиотеки:

```
nm /usr/lib/x86_64-linux-gnu/libjpeg.a
jlibinit.o:
0000000000000000 B auxv
                 U fclose
                 U fopen
                 U fread
                 U getpagesize
0000000000000000 T libjpeg_general_init
                 U malloc
                 U perror

jcapimin.o:
                 U jinit_marker_writer
                 U jinit_memory_mgr
0000000000000000 T jpeg_CreateCompress
                 U jpeg_abort
0000000000000240 T jpeg_abort_compress
                 U jpeg_destroy
0000000000000230 T jpeg_destroy_compress
00000000000002a0 T jpeg_finish_compress
                 U jpeg_natural_order
...
...
```

Команда "nm" перичисляет символы, содержащиеся в объектном файле или разделяемой библиотеке.

Используйте команду `nm -D libctest.so.1.0`
(or `nm --dynamic libctest.so.1.0`)

```
0000000000100988 A __bss_start
000000000000068c T ctest1
00000000000006a0 T ctest2
                 w __cxa_finalize
00000000001007b0 A _DYNAMIC
0000000000100988 A _edata
0000000000100990 A _end
00000000000006f8 T _fini
0000000000100958 A _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
00000000000005b0 T _init
                 w _Jv_RegisterClasses
```

Обратите внимание, что другие платформы (Cygwin) могут и не отреагировать на "-D". Попробуйте `nm -gC libctest.so.1.0`

| Тип символа | Описание |
| - |:-------------:|
| A | Значения символа абсолютное и не изменится во время дальнейшего связывания |
| B | Неинициализрованный раздел данных |
| D | Инициализированный раздел данных |
| T | Обычная секция кода |
| U | Неопределенный символ, который используется. Зависимость к другой библиотеке. |
| W | Дважды определенный символ. Если находится, позволяет определению из другой библиотеке разрешить зависимость. |

##### readelf: перечислить символы в разделяемых библиотеках

Команда "readelf" перечисляет символы, находящиеся в разделяемой библиотеке:

```
readelf -s /usr/lib64/libjpeg.so

Symbol table '.dynsym' contains 144 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000003b30     0 SECTION LOCAL  DEFAULT   10 
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND getenv@GLIBC_2.2.5 (4)
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND free@GLIBC_2.2.5 (4)
     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND ferror@GLIBC_2.2.5 (4)
     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fread@GLIBC_2.2.5 (4)
     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fclose@GLIBC_2.2.5 (4)
     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (5)
     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memset@GLIBC_2.2.5 (4)
     9: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
...
...
```

### Версии библиотек

Версия библиотеки должна быть указана для разделяемых объектов, если в библиотеку может быть включено большее или меньшее количество функций, меняется прототип функции или тип данных.

Версия библиотеки может быть указана, когда она состается. Если предполагается, что библиотека будет обновлена, то следует указать ее версию. Это особенно важно для библиотек, которые связываются динамически. Это позволяет избежать "Ада DLL", как в Microsoft, который заключается в конфликтах библиотек, возникающем при обновлении системы, которые меняет стандартную библиотеку, что приводит к поломке старого приложения, которое ожидает доступ к старой версии разделяемой библиотечной функции.

Версионность также возникает и в библиотеках GNU C. Это зачастую приводит к несовместимости бинарных файлов, скомпилированных с одной версией инструментов GNU с теми, которые были скомпилированы с другими версиями. Благодаря контролю версий, несколько различных версий библиотеки могут сосуществовать в рамках одной системы. Версия библиотеки включана в самвольное имя, так что линкер знает, с какой версией связываться.

Можно посмотреть символ версии, которая используется:

```
nm csub1.o
00000000 T ctest1
```

По умолчанию версия не указывается в объектном коде.

Есть один флаг компилятора GNU C/C++ который явно предназначен для версионирования символов. Укажите версию скрипта, которую вы будете использовать во время компиляции при помощи флага: `--version-script=файл-с-вашей-версией-скрипта`

**Важно:** Это полезно только при создании разделяемых библиотек. Предполагается, что разработчик знает, какие библиотеки связывать при статическом связывании. Связывание во время исполнения допускает несовместимость библиотек.

Примеры версионирования скриптов для GNU/Linux смотрите здесь:  sysdeps/unix/sysv/linux/Versions

Некоторые символы могут также получить строки с версиями из кода ассемблера, который находится в заголовочных файлах glibc. Смотрите в include/libc-simbols.h

Пример:

```
nm /lib/libc.so.6 | more
00000000 A GCC_3.0
00000000 A GLIBC_2.0
00000000 A GLIBC_2.1
00000000 A GLIBC_2.1.1
00000000 A GLIBC_2.1.2
00000000 A GLIBC_2.1.3
00000000 A GLIBC_2.2
00000000 A GLIBC_2.2.1
00000000 A GLIBC_2.2.2
00000000 A GLIBC_2.2.3
00000000 A GLIBC_2.2.4
...
..
```

Обратите внимание на использования скрипта версионирования.

Библиотека указывающая на версию библиотеки:

```
nm /lib/libutil-2.2.5.so
..
...
         U strcpy@@GLIBC_2.0
         U strncmp@@GLIBC_2.0
         U strncpy@@GLIBC_2.0
...
..
```

### Динамическая загрузка и выгрузка разделяемых библиотек при помощи libdl

Эти библиотеки динамически загружаются / выгружаются и связываются во время выполнения. Полезно при создании архитектуры типа "plug-in".

Прототип включения файла библиотеки ctest.h

```C
#ifndef CTEST_H
define CTEST_H

#ifdef __cplusplus
extern "C" {
#endif

void ctest1(int *);
void ctest2(int *);

#ifdef __cplusplus
}
#endif

#endif
```

Используйте нотацию extern "C", чтобы библиотеки могли использоваться как в C, так и в C++. Эта инструкция предотвращает C++ от замещения имен и таким образом создание "неразрешенных символов" при связывании.

Загружайте и выгружайте библиотеку libctest.so динамически:

```C
#include <stdio.h>
#include <dlfcn.h>
#include "ctest.h"

int main(int argc, char **argv)
{
   void *lib_handle;
   double (*fn)(int *);

   int x;
   char *error;

   lib_handle = dlopen("/opt/lib/libctest.so", RTLD_LAZY);
   if (!lib_handle) {
      fprintf(stderr, "%s\n", dlerror());
      exit(1);
   }

   fn = dlsym(lib_handle, "ctest1");
   if ((error = dlerror()) != NULL)  {
      fprintf(stderr, "%s\n", error);
      exit(1);
   }

   (*fn)(&x);
   printf("Valx=%d\n",x);

   dlclose(lib_handle);
   return 0;
	}
```

`gcc -rdynamic -o progdl progdl.c -ldl`

Объяснение:
- `dlopen("/opt/lib/libctest.so", RTLD_LAZY);`
Открывает разделяемую библиотеку с именем "libctest.so". 
Второй аргумент указывает на связку. См. включенный файл dlfcn.h. 
Возвращает NULL, если не удалось. 
Опции:
	- RTLD_LAZY: Если указано, Linux не заботится о неразрешенных символах, пока к ним не произошло обращение.
	- RTLD_NOW: Все неразрешенные символы разрешены при вызове dlopen().
	- RTLD_GLOBAL: Сделать библиотеку символов видимой.
- `dlsym(lib_handle, "ctest1");`
Возвращает адрес функции, которая была загружена разделяемой библиотекой. Возвращает NULL, если не удалось. 

**Расположение объектного кода:** Архивные библиотеки объектного кода могут быть расположены либо с исполняемым файлом либо с загружаемыми библиотеками. Процедуры объектного кода, используемые в обоиз не должны дублироваться. Это особенно важно для кода, который использует статичные переменные. Статичная переменная глобальна и таким образом может быть представлена единым образом. Включение ее дважды приведет к непредсказуемому результату. Разработчик может указать, что конкретный объектный код должен быть связан с исполняемым посредством использования команд линковщика, которые передаются компилятору.

Используйте флаг "-Wl" компилятора gcc для передачи аргументов командной строки линковщику GNU "ld"

Пример выражения в сборочном файле: `g++ -rdynamic -o appexe $(OBJ) $(LINKFLAGS) -Wl,--whole-archive -L{AA_libs} -laa -Wl,--no-whole-archive $(LIBS)`

- --whole-archive: Эта директива линковщика указывает, что перечисленные после нее библиотеки (в данном случае AA_libs) должны быть включены в результат, даже если никаких вызовов из них не происходит. Эта опция используется для указания библиотек, которые загружаемые библиотеки потребуеют во время исполнения.

- -no-whole-archive: Это необходимо указать независимо от того, перечисляете вы дополнительные объектные файлы или нет. Компилятор gcc добавит его собтвенный список архивных библиотек и вы не хотетите связать их все со своим результатом в случае, если они не нужны. Этот флаг переключает поведение на нормальное для остальных архивных библиотек.

### Сравнение с Microsoft DLL

Эквивалент Microsoft для разделяемого объекта в Linux / Unux (".so") - это ".dll". Файл Microsoft Windows DLL как правило имеет расширение ".dll", но многие могут также использовать расширение ".ocx". На старых 16-битных windows-машинах динамически подключаемые библиотеки также имели суффик ".exe". "Выполнение" DLL приведет к ее загрузке в память.

### Кросс-платформенное написание загружаемых библиотек

```C
#ifndef USE_PRECOMPILED_HEADERS
#ifdef WIN32
#include <direct.h>
#include <windows.h>
#else
#include <sys/types.h>
#include <dlfcn.h>
#endif
#include <iostream>
#endif

    using namespace std;

#ifdef WIN32
    HINSTANCE lib_handle;
#else
    void *lib_handle;
#endif

    // Where retType is the pointer to a return type of the function
    // This return type can be int, float, double, etc or a struct or class.

    typedef retType* func_t;  

    // load the library -------------------------------------------------
#ifdef WIN32
    string nameOfLibToLoad("C:\opt\lib\libctest.dll");
    lib_handle = LoadLibrary(TEXT(nameOfLibToLoad.c_str()));
    if (!lib_handle) {
        cerr << "Cannot load library: " << TEXT(nameOfDllToLoad.c_str()) << endl;
    }
#else
    string nameOfLibToLoad("/opt/lib/libctest.so");
    lib_handle = dlopen(nameOfLibToLoad.c_str(), RTLD_LAZY);
    if (!lib_handle) {
        cerr << "Cannot load library: " << dlerror() << endl;
    }
#endif

...
...
...

    // load the symbols -------------------------------------------------
#ifdef WIN32
    func_t* fn_handle = (func_t*) GetProcAddress(lib_handle, "superfunctionx");
    if (!fn_handle) {
        cerr << "Cannot load symbol superfunctionx: " << GetLastError() << endl;
    }
#else
    // reset errors
    dlerror();

    // load the symbols (handle to function "superfunctionx")
    func_t* fn_handle= (func_t*) dlsym(lib_handle, "superfunctionx");
    const char* dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol superfunctionx: " << dlsym_error << endl;
    }
#endif

...
...
...

    // unload the library -----------------------------------------------

#ifdef WIN32
    FreeLibrary(lib_handle);
#else
    dlclose(lib_handle);
#endif
```

### Инструменты

Мануалы:
- [ar](http://man.yolinux.com/cgi-bin/man2html?cgi_command=ar) - создание, модификация и экспорт из архивов
- [ranlib](http://man.yolinux.com/cgi-bin/man2html?cgi_command=ranlib) - генерация индекса архива
- [nm](http://man.yolinux.com/cgi-bin/man2html?cgi_command=nm) - перечислить символы из объектных файлов
- [ld](http://man.yolinux.com/cgi-bin/man2html?cgi_command=ld) - Линковщик
- [ldconfig](http://man.yolinux.com/cgi-bin/man2html?cgi_command=ldconfig) - конфигурация динамического линковщика связей времени выполнения
	`ldconfig -p` - распечатать список директорий и библиотек, хранящихся в текущем кеше
	Например, `/sbin/ldconfig -p |grep libGL`
- [ldd](http://man.yolinux.com/cgi-bin/man2html?cgi_command=ldd) - выводит зависимости разделяемой библиотеки
- [gcc/g++](http://man.yolinux.com/cgi-bin/man2html?cgi_command=gcc) - компилятор проекта GNU для C и C++
- [ld.so](http://man.yolinux.com/cgi-bin/man2html?cgi_command=ld.so) динамический линкер/загрузчик a.out

### Дополнительно

- Указание загрузчику заранее загрузить указанную разделяемую библиотеку до всех остальных: `LD_PRELOAD=/usr/lib/libXXX.so.x; exec program`. Это указано в файле /etc/ld.so.preload и расширяемо при помощи переменной окружения LD_PRELOAD. 
Также смотрите:
	- [ld.so](http://man.yolinux.com/cgi-bin/man2html?cgi_command=ld.so) динамический линкер/загрузчик a.out
	- [LD_PRELOAD и пересечение функий в Linux](https://scaryreasoner.wordpress.com/2007/11/17/using-ld_preload-libraries-and-glibc-backtrace-function-for-debugging/)
- Компиляция, совместимая с Red Hat 6.2 из Red Hat 7.1 (glibc 2.2.2). См. [RELEASE NOTES](ftp://herbie.ucs.indiana.edu/pub/linux/redhat/redhat/redhat-7.1-en/os/i386/RELEASE-NOTES)
`export LD_ASSUME_KERNEL=2.2.5. /usr/i386-glibc21-linux/bin/i386-glibc21-linux-env.sh`

- Переменная окружение для подсветки предупреждений, ошибок и так далее: `export CC="colorgcc"`

### Ссылки

-[Оригинал статьи + информация для C++](http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html)
- [LDP: разделяемые библиотеки](http://www.tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)
- [Мануал objdump](man.yolinux.com/cgi-bin/man2html?cgi_command=objdump)
- [Мануал readelf](http://man.yolinux.com/cgi-bin/man2html?cgi_command=readelf)
- [ld и схема объектных файлов](sourceware.org/binutils/docs-2.22/ld/index.html)
- [Версионирование символов](gcc.gnu.org/ml/gcc-help/2004-03/msg00265.html)
- [Мануал dlopen()](http://man.yolinux.com/cgi-bin/man2html?cgi_command=dlopen) - получение доступа к исполняемому объектному файлу
- [Мануал dclose()](http://man.yolinux.com/cgi-bin/man2html?cgi_command=dlclose) - закрыть объект dlopen()
- [Мануал dlsym()](http://man.yolinux.com/cgi-bin/man2html?cgi_command=dlsym) - получить адрес символа из объекта dlopen
- [Мануал dlvsym()](http://man.yolinux.com/cgi-bin/man2html?cgi_command=dlvsym) - программный интерфейс для динамического загрузчика связей
- [Мануал dlerror()](http://man.yolinux.com/cgi-bin/man2html?cgi_command=dlerror) - получение диагностической информации
- [GNOME Glib dynamic loading of modules](https://developer.gnome.org/glib/2.32/glib-Dynamic-Loading-of-Modules.html) - кросс-платформенный API для динамической загрузки плагинов