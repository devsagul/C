# Лекция 4

Темы, которые будут рассмотрены в этой лекции:

- IDE или не IDE?;
- Инструменты разработчика: редактор, компилятор, дебаггер;
- Системы контроля версий;
- Vim;
- gcc;
- gdb;
- git.

## IDE или не IDE?

Сегодня большинство разработчиков используют различные IDE (Integrated development environment - интегрированная среда разработки), но это не означает, что этот путь - единственный. Безусловно, у использования IDE есть огромное количество плюсов: они легко настраиваются, обладают современными инструментами, которые интегрированы вместе, часто поддерживают несколько языков программирования и т.д. Основными проблемами являются: IDE часто тяжеловесны, поддерживают даже если и большое, то ограниченное кол-во языков программирования, не всегда обеспечивают простой перенос конфигурации с одного компьютера на другой, имеют ограниченные возможности для расширения. Одна из самых удобных IDE для разработик на C является CLion, но я предлагаю на некоторое время намеренно отказаться от IDE, чтобы подробнее изучить каждый из инструментов.

## Инструменты разработчика: редактор, компилятор, дебаггер

Давайте на секунду задумаемся о том, зачем нам IDE. Что мы там делаем? Пишем код, компилируем и отлаживаем его. Рассмотрим инструменты для этого по отдельности.

Понятно, что нам придется где-то писать код. Вероятнее всего, ваш дистрибутив операционной системы включает некоторый текстовый редактор (например, Notepad в ОС семейства Windows), но он плохо полходит для этих целей, т.к. как правило ограничен в возможностях подстветки синтаксиса, установки расширений, добавления пользовательских сценариев и т.д. Альтернативами стандартному текстовому редактору являются Sublime, Atom, VS Code, Notepad++, Emacs и Vim и др. Emacs и Vim сильно выделяются на фоне остальных, т.к. они довольно сложны в освоении ("Как выйти из Vim?" - один из самых популярных вопросов на StackOverflow), но при этом оба являются крайне мощными инструментами в руках опытного пользователя.

Emacs VS Vim - тема многих холиваров. Мы остановимся на Vim, т.к. с довольно высокой вероятностью либ Vim, либо Vi установлен в вашей системе по умолчанию.

Предположим, что мы разобрались с текстовым редактором и готовы двигаться дальше. Теперь нам необходимо скомпилировать написанный код. Для этого воспользуемся компилятором gcc: он прост в использовании, имеет открытый исходный код и доступен на крайне многих платформах. Список различных кмопиляторов C можно найти [тут](https://en.wikipedia.org/wiki/List_of_compilers#C_compilers).

Конечно, в мире найдутся программисты, которые будут заявлять, что они пишут идеальный код без ошибок. Но у меня так не получается. Из-за этого иногда возникает необходимость воспользоваться специальной программой для отладки программ - дебаггером. В дальнейшем мы будем использовать gdb, а список различных вариантов как обычно смотрите [здесь](https://en.wikipedia.org/wiki/List_of_debuggers).

## Системы контроля версий

Как быть, если вчера наша программа работала, а сегодня мы внесли несколько изменений и все сломалось? Как вернуться назад? Где возможно достать машину времени?

Хорошая новость заключается в том, что подобная машина времени придумана давно и выражена в рамках концепции системы контроля версий. Смысл заключается в том, что мы фиксируем состояние нашей системы в нужных точках времени и при необходимости "откатываемся" к одной из них. Конечно, функционал системы контроля версий значительно шире, но об этом речь пойдет ниже на примере одной из них, а именно git. С большим списком систем контроля версий можно ознакомиться [здесь](https://en.wikipedia.org/wiki/List_of_version_control_software).

## Vim: самое необходимое

Vim может сильно отличаться от всего, что вы использовали до этого. Если вы решили не использовать GUI для него, то все команды будут вводиться с клавиатуры при помощи специальных сочитаний клавиш. При этом у него есть шесть основных режимов работы:

- Normal
- Visual
- Select
- Insert
- Command-line
- Ex

Подробное описание и способы переключения между режимами вы можете найти [здесь](http://vimdoc.sourceforge.net/htmldoc/intro.html#vim-modes-intro).

Что же нам нужно знать, чтобы начать эффективно работать в Vim? Конечно, необходимо как минимум получить то самое сакральное знание, как выходить из текстового редактора. Для того, чтобы гарантировано выйти из Vim и отменить все сделанные изменения используется сочетание <Esc>:qa!. Где <Esc> - переход в режим Normal, : - переход в режим Command-line, q - команда на выход, a - команда abort для отмены всех изменений и ! - директива force для того, чтобы выйти независимо от остальных требований.

Рассмотрим самые необходимые из команд:

### Базовое перемещение курсора

| Команда | Функция |
| - |:-------------:|
| h l j k | перемещение соответственно на символ влево, вправо, на строчку вниз, вверх |
| b w | перемещение на слово влево, вправо |
| ge e | перемещение на конец слова слева, справа |
| { } | к началу предыдущего, следуюшего параграфа |
| ( ) | к началу предыдущего, следующего предложения |
| 0 gm | к началу, середине строки |
| ^ $ | к первому, последнему (не пробельному) символу строки |
| nG ngg | к строке n, по умолчанию к последней, первой строке |
| n% | к n-ому проценту файла (n обязательно) |
| nj | к n-ому символу текущей строки |
| % | к парному элементу по отношению к скобке под курсору, открывающей скобке комментария, дерективе #define |
| nH nL | к n-ой строке от начала, конца окна |
| M | к средней строке окна|

### Вставка и замена

| Команда | Функция |
| - |:-------------:|
| i a | вставка перед, после курсора |
| I A | вставка в начале, конце строки |
| gI | вставка текста в первую колонку |
| o O | вставка в новой строке ниже, выше текущей |
| rc | заменить символ под курсором на c |
| R | замена символов начиная с символа под курсором |
| cm | замена текста, который находится там, куда указывает команда движения m |
| cc или S | ззамена текущей строки |
| C | замена до конца файла |
| s | замена одного символа и переход в режим вставки |
| ~ | поменять регистр символа под курсором и переход к следующему символу |
| g~m | поменять регистр текста, который находится там, куда указывает команда движения m |
| gum gUm | перевести текст, который находится там, куда указывает команда движения m в верхний, нижний регистр |
| <m >m | сместить текст, который находится там, куда указывает команда движения m влево, вправо |
| n<< n>> | сместить n строк влево, вправо |

### Удаление

| Команда | Функция |
| - |:-------------:|
| x X | удаление символа под, перед курсором |
| dm | удаление текста, который находится там, куда оказывет команда движения m |
| dd D | удаление текущей строки, удаление до конца текущей строки |
| J gJ | конкатенация текущей строки со следующей, без пробела |
| :rd<Enter> | удаление строк в диапозоне r |
| :rdx<Enter> | удаление строк в диапозоне r и вставка их в регистр x |


### Режим вставки

| Команда | Функция |
| - |:-------------:|
| ^Vc ^Vn | вставка символа, по десятичному значению |
| ^A | вставка вставленного прежде текста |
| ^@ | то же, что и ^A, только выходит из режима вставки и переходит в командный режим |
| ^Rx ^R^Rx | вставка содержимого регистра x |
| ^N ^P | автодополнение текста до, после курсора |
| ^W | удаление слова перед курсором |
| ^U | удаление всех вставленных символо в текущей строке |
| ^D ^T | смещение влево, вправа на одну ширину смещения |

### Копирование

| Команда | Функция |
| - |:-------------:|
| "x | использовать регистр x для следующего удаления, копирования, вставки |
| :reg<Enter> | показать содержимое всех регисров |
| :reg x<Enter> | показать содержимое регистра x |
| ym | копирование текста, который находится там, куда указывает команда движения m |
| yy или Y | скопировать текущую строку в регистр |
| p P | всиавка регистра до, после позиции курсора |
| ]p [p | то же, что и p P, но выполняет отступы |
| gp gP | то же, что и p P, но переводит курсор после вставленного текста |

### Продвинутая вставка

| Команда | Функция |
| n^A n^X | +n, -n к числу под курсором (по умолчанию - 1) |
| gqm | отформатировать строки, которые находятся там, куда указывает команда движения m по фиксированной ширине |
| :rce w<Enter> | отцентрировать строки в диапозоне r по ширине w |
| :rle i<Enter> | выровнять по левой границе строки в диапозоне r с отступом i |
| :rri w<Enter> | выровнять по правой границе строки в диапозоне r по ширине w |
| !mc<Enter> | отфильтровать строки, которые находятся там, куда указывает команда движения m, при помощи команды c |
| n!!c <Enter> | отфильтровать n строк при помощи команды c |
| :r!c<Enter> | отфильтровать строки в диапозоне r при помощи команды c |

### Режим Visual

| Команда | Функция |
| - |:-------------:|
| v V ^V | начать/закончить подсветку символов, строк, блоков |
| o | перевести курсор на начала подсвеченного участка |
| gv | начать подстветку предыдущей визуальной зоны |
| aw as ap | выбрать слово, предложение, параграф |
| ab aB | выбрать блок, заключенный в (), {} |

### Отмена и повтор команды



## Быстрый старт с gcc

Если вы используете Unix-подобную операционную систему, то для установки компилятора gcc, установите пакет gcc или g++. Для пользователей операцонных систем семейства Windows есть несколько вариантов:

- активация подсистемы Ubuntu (доступна для пользователей Windows 10 x64);
- MinGW;
- Cygwin.

Для компиляции программы в gcc введите команду

`gcc -ansi -pedantic *.c -o a.out`

Где -ansi - флаг для использования стандарта ANSI C (эквивалентный флаг -std=c90), -pedantic - флаг для вывода всех предупреждений, если код не удовлетворяет требованиям стандарта (эквивалентный флаг -Wpedantic), *.c - команда для использоывания в качестве исходных файлов все файлы с расширением .c, -o a.out - флаг для сборки и ликовки объектного кода в файл a.out.

## Использование gdb

Сначала скомпилируйте вашу программу с флагом -g (GDB debugging):

`gcc -g *.c -o a.out`

Для того, чтобы начать отладку прогаммы, скомпилированной в a.out в gdb выполните команду

`gdb a.out`

Для установки точки прерывания (breakpoint) в строке с номером n используйте команду

`(gdb) b n`

Для запуска прогаммы в отладчике используется команда

`(gdb) run`

После этого программа будет выполняться как обычно, пока не встретит точку прерывания.

Для выполнения следующего шага используются команды next и step, при этом, если на следующем шаге вызывается какая-либо функция, команда next выполнит ее полностью, а команда step начнет ее отладку с первой строки этой функции.

Для того, чтобы понять, где мы сейчас находимся внутри нашей программы, используется команда

`(gdb) bt`

Для вывода значения переменной x используется команда

`(gdb) print x`

Для выхода из отладчика используется команда

`(gdb) quit`

## Очень кратко о git

### создадим первый репозиторий

#### итак, с чего же начать?

Дадим системе понять, кто мы такие:

1. `git config --global user.name "John Doe"`
2. `git config --global user.email foo@citrix.com`


### создадим проект

1. создадим папку с нашим будущим проектом `mkdir myfirstrepo`
2. зайдем в папку `cd myfirstrepo` 
3. инициализируем репозиторий  
`git init`

![](pics/1.png)

#### создадим в нем пустой файл и добавим в него текст

![](pics/2-3.png)

#### немного о структуре репозитория
любой git-репозиторий состоит из трех "деревьев", в которых хранятся изменения:

- `working directory` - рабочая папка, в которой содержатся файлы в отредактированном виде
- `Index` - выступает в роли "временного фиксатора"
- `HEAD` - файлы находятся в состоянии последнего сделанного коммита

![http://rogerdudler.github.io/](http://rogerdudler.github.io/git-guide/img/trees.png)

#### посмотрим, что стало с нашим репозиторием

`git status`

![](pics/4.png)

#### добавим наш новый файл в `Index`

`git add .`

![](pics/5.png)

#### создадим __commit__ (отпечаток) наших изменений, добавив наш файл в `HEAD`

`git commit -m "my first commit"`

![](pics/6.png)

### Использование Github как хостинг для репозитория

#### создадим репозиторий на Github

![](pics/7.png)

#### создадим репозиторий на Github

![](pics/8.png)

#### создадим репозиторий на Github

![](pics/9.png)

#### сделаем наш локальный репозиторий общедоступным

поступим, как нам советуют на Github, в случае, если репозиторий уже существует:
- добавим _remote_ по имени _origin_, т.е. путь к серверу, на котором будет храниться код  
`git remote add origin https://github.com/murych/myfirstproject.git`
- зальем наш код в _remote_ в ветку _master_  
`git push -u origin master`
- введем логин и пароль

![](pics/10.png)

#### voila~

![](pics/11.png)

#### voila~

![](pics/12.png)

### Принимаем участие в "разработке" чужих проектов

А теперь - немного практики! Найдем репозиторий нашего сообщества, сохраним себе, и даже внесем небольшой вклад в общее дело!

- заходим на [Github](https://github.com/) и ищем пользователя `lambdafrela`

![](pics/13.png)

- выбираем **репозиторий** `myfirstproject` и создадем **форк** репозитория, т.е. вашу личную его копию, над которой вы имеете полную власть

![](pics/14.png)

![](pics/15.png)

- склонируем репозиторий на свой компьютер  
`git clone https://github.com/murych/myfirstproject.git`

![](pics/16.png)

- создадим файл под названием `ваше_имя.txt`, в который запишем ваш email

![](pics/17.png)

- сделаем коммит и запушим изменения в форк

![](pics/18.png)

- теперь, когда наши изменения есть в форке, мы можем сделать запрос на добавление их в исходный репозиторий __Pull Request__

![](pics/19.png)

- в поле _base fork_ укажем __исходный__ репозиторий
- в поле _head fork_ укажем свой форк
- нажмем на кнопку __Create pull request__

![](pics/20.png)

![](pics/21.png)

### ветвление (branches)

![](pics/2/branch.png)

#### немного команд

- `git checkout -b develop` - создать новую ветку `develop` и переключиться на нее
- `git branch` - показать все ветки
- `git checkout master` - переключиться на главную ветку
- `git merge <branch>` - слить текущую ветку с веткой `<branch>`
- `git branch -d <branch>` - удалить ветку 
 - `-D` - принудительно удалить ветку
- `git merge <branch> --squash` - при слиянии веток собрать несколько коммитов в один

#### создадим ветку `develop`
`git checkout -b develop`  

и посмотрим, какие ветки у нас теперь есть:  

`git branch`

![](pics/2/10.png)

#### внесем в эту ветку изменения
например, поменяем файл `hello.txt` и закоммитим его новое состояние

![](pics/2/11.png)

#### таким образом, у нас есть две версии файла `hello.txt`, между которыми можно переключаться

![](pics/2/13.png)

#### чтобы наши изменения оказались в главной ветке, их надо слить

переключившись в ветку `master`, выполним:

`git merge develop`

![](pics/2/14.png)

![](pics/2/merge_meme.jpg)

[Разница между `git merge --no-ff` и `git merge`](https://stackoverflow.com/questions/9069061/what-is-the-difference-between-git-merge-and-git-merge-no-ff)

![](pics/2/merge.png)

### заначки (stash)

#### немного команд
- `git stash` - _спрятать_ свои правки
- `git stash apply` - применить изменения к текущей версии
- `git stash list` - вывести список изменений
- `git stash show` - вывести последние изменения
- `git stash drop` - удалить последние изменения в списке 
- `git stash pop` - [`apply`] + [`drop`]
- `git stash clear` - очистить список изменений

допустим, в главном репозитории полным ходом идет разработка

![](pics/2/1.png)

мы, в свою очередь, тоже не отстаем и изо всех сил вносим изменения

![](pics/2/2.png)

в таком случае, при попытке получить актуальную версию кода, Git одарит нас ошибкой:

![](pics/2/3.png)

#### что же делать? -- прятать свой ~~говно~~код!

`git stash`

![](pics/2/4.png)

#### теперь мы можем скачать код из главного репозитория и попробовать применить свои изменения

`git pull`

`git stash pop`

![](pics/2/5.png)

#### путь только один -- исправлять конфликт ручками

для этого можно использовать редактор/IDE/специальные программы для решения конфликтов, аля [Meld](http://meldmerge.org/)

![](pics/2/8.png)

#### когда конфликт разрешен, можно спокойно отправлять свой код в репозиторий

![](pics/2/9.png)

![](pics/2/success.jpg)

### git workflow

[](https://habrastorage.org/storage/4bf7e68c/49e29c35/3a01bd6b/782a1be3.png)
![](pics/2/gitflow_1.jpg)

#### главные ветки - `master` и `develop`

![](http://nvie.com/img/main-branches@2x.png)

#### под каждый новый функционал - отдельную ветку `feature` от ветки `develop`
   
`git checkout -b my_feature develop`

![](http://nvie.com/img/fb@2x.png)

#### если в программе обнаруживается неисправность, требующая срочных исправлений - создается ветка `hotfix` от `master`, которая потом сливается и с `master`, и с `develop`

`git checkout -b hotfix master`

`git checkout master`

`git merge --no-ff hotfix`

`git branch -d hotfix`

![](https://habrastorage.org/storage/a303d38c/6c9c561c/8bcc22f7/3f8cbad4.png)

### semantic versioning

__ТЭГ__ == __Релиз__, используется для фиксирования версий вашего ПО

#### немного команд
- `git tag <name>` - создать тэг (например, v1.3.1)
- `git push --tags` - залить все тэги в репозиторий
- `git push <tag>` - залить конкретный тэг в репозиторий


Номер версии в формате __MAJOR.MINOR.PATCH__ задается следующим образом:

1. __MAJOR__ версия - увеличивается, когда сделаны обратно несовместимые изменения API (крупные релизы)
2. __MINOR__ версия - увеличивается, когда добавляется новый функционал, не нарушающий обратной совместимости (новые фичи)
3. __PATCH__ версия - увеличивается, когда вы делаете обратно совместимые исправления (исправления, фиксы)

### tips&tricks

![](pics/2/linus_meme.jpg)

- если допущена ошибка при создании коммита (не те файлы, не тот комментарий), её можно откатить
```bash
git reset --soft HEAD^
```

- если нужно посмотреть содержимое другой ветки, а в текущей есть файлы, еще **не** добавленные в Index:
```bash
git stash save --include-untracked
```

- если отредактировано много файлов и добавлять сразу все __НЕ хочется__, то можно использовать `git add -i`

![](pics/2/18.png)

- файл `.gitignore` содержит описание файлов, которые git не будет отслеживать
    - например, если мы не хотим, чтобы в репозитории хранилась папка `.idea` и  все файлы формата `dll`, то пишем:
        - `.idea/`
        - `*.dll`

![](pics/2/15.png)

- `git log` - посмотреть историю коммитов в проекте

![](pics/2/16.png)

- `git lg` - один из альтернативных вариантов истории коммитов, более наглядный для его использования надо создать алиас:

```bash
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%C(bold blue)<%an>%Creset' --abbrev-commit"
```

![](pics/2/17.png)

- использование GUI клиентов `¯\_(ツ)_/¯`

 - [GitExtensions](https://gitextensions.github.io/)
![](pics/2/gitextensions.png)

- использование GUI клиентов `¯\_(ツ)_/¯`

 - [GitKraken](https://www.gitkraken.com/)
![](https://git-scm.com/images/guis/git-kraken@2x.png)

- использование GUI клиентов `¯\_(ツ)_/¯`

 - [SourceTree](https://gitextensions.github.io/)
![](https://www.sourcetreeapp.com/dam/jcr:580c367b-c240-453d-aa18-c7ced44324f9/hero-mac-screenshot.png?cdnVersion=hp)

## ДЗ

- Кастомизировать свой Vim при помощи расширений с [Vim Awesome](https://vimawesome.com/)
- Завести git-репозиторий со своим проектом
- Выложить его не Github
- Сообщить об этом мне
- Склонировать репозиторий с лекциями
- Исправить опечатки и сделать pull-request
- Приступить к разработке индивидуального проекта (по поводу идей для проекта обращаться ко мне)

## Дополнительное чтение

- [Vim](http://vimdoc.sourceforge.net/htmldoc/help.html)
- [gcc](http://www.network-theory.co.uk/docs/gccintro/)
- [gdb](http://sourceware.org/gdb/current/onlinedocs/gdb/)
- [git](https://git-scm.com/book/en/v2)

## Благодарности

Отдельная благодарность Тимуру Майзенбергу и Николаю Голубеву за предоставленные материалы

